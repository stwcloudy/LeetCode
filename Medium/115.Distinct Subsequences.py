"""
本题是“求序列B是否是序列A的子序列”的扩展，扩展为求能在序列A中找出多少个序列B作为其子序列
先来看原始问题的解法，可以简单的使用动态规划的思想来做
bool类型数组dp[i][j] = 1 表示B[0-j]是A[0-i]的子序列，反之亦然。
1.若B[j] == A[i] , 则dp[i][j] = dp[i-1][j-1]
2.若B[j] != A[i] , 则dp[i][j] = dp[i-1][j]

dp的思想同样可以扩展到本题，用dp[i][j]表示在A[0~(j-1)]中找到多少个序列B[0~(i-1)],最终的结果存储在dp[len(B)][len(A)]中
初始情况：
1. B为空的情况,dp[0][j] = 1, 表示此时B为任意序列的子序列且只能找到一次，即数组的第一行全为1
2. A为空的情况,dp[i][0] = 0 (i != 0)
有了初始化的情况之后，就可以直接给出某个序列为空的情况下的结果，不需要在代码中特殊判断，此时转移情况分两类：
1. B[i-1] != A[j-1],此时dp[i][j]只能由数组同一行的上一个即dp[i][j-1]决定，dp[i][j] = dp[i][j-1]
2. B[i-1] == A[j-1],此时dp[i][j]可由两种方式转移得到，一种是由之前的dp[i-1][j-1],另一种就是同一行的
dp[i][j-1],所以 dp[i][j] = dp[i-1][j-1] + dp[i][j-1]

最后结果即为dp[len(B)][len(A)]
代码如下
"""

m,n = len(s), len(t)
        dp = [[0 for _ in range(m+1)] for j in range(n+1)]
        for j in range(m + 1):
            dp[0][j] = 1
        for i in range(n):
            for j in range(m):
                if t[i] == s[j]:
                    dp[i+1][j+1] = dp[i][j] + dp[i+1][j]
                else:
                    dp[i+1][j+1] = dp[i+1][j]
        return dp[n][m]